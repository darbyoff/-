1. Разобрать программу, выводящую содержимое текстового файла на экран. Как можно сократить текст программы?
#include <stdio.h>
void main(void)
{
char ch, name[50];
FILE *in;
printf (“Введите имя файла для просмотра: ”);
scanf (“%s”, name);
if((in=fopen (name, “r”))==NULL)
printf (“Файл %s не открыт”, name);
else
while (!feof (in))
{
ch=getc(in) ;
putchar (ch) ;
}
}
2. Дополнить программу предыдущего пункта функцией подсчета «пустых» и «непустых» символов в текстовом файле. Под «пустыми» символами понимаются символы, не отображающиеся на экране: управляющие символы, пробел, звуковой сигнал и т. .
3. Дополнить программу первого пункта функцией поиска в текстовом файле заданной подстроки. Искомую подстроку необходимо передавать в качестве параметра функции. Результаты работы сформировать в отдельном файле.
4. Написать программу, которая обрабатывает текстовый файл следующим образом.
B исходном тексте номера страниц проставлены B перпой строке страницы. Требуется перенести эти номера в последнюю строку страницы и убрать знаки переноса. Например, номер страницы: - 34 -. Необходимо получить 34.
Признаком — персхода на — следующую — страницу — является управляющий символ “\f'.
5. Написать программу-шифратор файлов. Она читает из файла и пишет в другой файл закодированные символы.
Схема шифровки: c = с^kеу[i], где с — символ, считанный из файла; key — ключ шифрования, строка, которая передается как параметр командной строки. Программа используется символы из Кеу циклически, пока не будет считан весь ввод.
Для проверки правильности программы зашифровать зашифрованный файл еще раз с тем же ключом. Должен получиться файл — ТОЧНАЯ копия исходного файла.
6. Дополнить программу п. 5 возможностью вводить имя файла и ключ из командной строки.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


1. Вывод содержимого текстового файла на экран
#include <stdio.h>

int main() {
    char ch, name[50];
    FILE *in;

    printf("Введите имя файла для просмотра: ");
    scanf("%s", name);

    if ((in = fopen(name, "r")) == NULL) {
        printf("Файл %s не открыт\n", name);
        return 1;
    }

    while ((ch = getc(in)) != EOF) {
        putchar(ch);
    }

    fclose(in);
    return 0;
}
В данной программе убраны лишние пробелы и добавлено закрытие файла после использования.

2. Подсчет «пустых» и «непустых» символов в текстовом файле
#include <stdio.h>

int main() {
    char ch, name[50];
    FILE *in;
    int emptyCount = 0, nonEmptyCount = 0;

    printf("Введите имя файла для анализа: ");
    scanf("%s", name);

    if ((in = fopen(name, "r")) == NULL) {
        printf("Файл %s не открыт\n", name);
        return 1;
    }

    while ((ch = getc(in)) != EOF) {
        if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') {
            emptyCount++;
        } else {
            nonEmptyCount++;
        }
    }

    printf("Пустых символов: %d\n", emptyCount);
    printf("Непустых символов: %d\n", nonEmptyCount);

    fclose(in);
    return 0;
}

3. Поиск заданной подстроки в текстовом файле и запись результатов в другой файл
#include <stdio.h>
#include <string.h>

int main() {
    char searchStr[50], filename[50], line[100];
    FILE *in, *out;

    printf("Введите имя файла для поиска подстроки: ");
    scanf("%s", filename);

    printf("Введите подстроку для поиска: ");
    scanf("%s", searchStr);

    if ((in = fopen(filename, "r")) == NULL) {
        printf("Файл %s не открыт\n", filename);
        return 1;
    }

    if ((out = fopen("result.txt", "w")) == NULL) {
        printf("Ошибка при создании файла result.txt\n");
        fclose(in);
        return 1;
    }

    while (fgets(line, sizeof(line), in) != NULL) {
        if (strstr(line, searchStr) != NULL) {
            fputs(line, out);
        }
    }

    printf("Результаты поиска записаны в файл result.txt\n");

    fclose(in);
    fclose(out);
    return 0;
}

4. Обработка номеров страниц в текстовом файле
#include <stdio.h>

int main() {
    FILE *in, *out;
    char line[100];

    if ((in = fopen("input.txt", "r")) == NULL) {
        printf("Файл input.txt не открыт\n");
        return 1;
    }

    if ((out = fopen("output.txt", "w")) == NULL) {
        printf("Ошибка при создании файла output.txt\n");
        fclose(in);
        return 1;
    }

    while (fgets(line, sizeof(line), in) != NULL) {
        fputs(line, out); // записываем строки в выходной файл
        if (line[0] == '-' && line[1] == ' ' && line[2] == '0') {
            fputs(line + 3, out); // записываем номер страницы без знака переноса
        }
    }

    printf("Номера страниц перенесены в последнюю строку в файле output.txt\n");

    fclose(in);
    fclose(out);
    return 0;
}

5. Программа-шифратор файлов
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("Использование: %s <input_file> <output_file> <key>\n", argv[0]);
        return 1;
    }

    FILE *in, *out;
    char ch;
    int keyIndex = 0;

    if ((in = fopen(argv[1], "r")) == NULL) {
        printf("Файл %s не открыт\n", argv[1]);
        return 1;
    }

    if ((out = fopen(argv[2], "w")) == NULL) {
        printf("Ошибка при создании файла %s\n", argv[2]);
        fclose(in);
        return 1;
    }

    while ((ch = fgetc(in)) != EOF) {
        ch ^= argv[3][keyIndex]; // XOR с символом из ключа
        fputc(ch, out);
        keyIndex = (keyIndex + 1) % strlen(argv[3]); // циклическое использование ключа
    }

    printf("Файл успешно зашифрован и записан в %s\n", argv[2]);

    fclose(in);
    fclose(out);
    return 0;
}

6. Добавление возможности ввода имени файла и ключа из командной строки
Программа из пункта 5 уже поддерживает передачу имени входного файла, выходного файла и ключа через аргументы командной строки. Таким образом, для ее использования достаточно запустить ее с соответствующими аргументами:

./program input.txt output.txt secret_key

Это позволяет достичь удобства и гибкости в работе с программой.
