1. Ознакомиться со структурой программы на языке С++. Для этого выполнить программу возведения числа 2 в степень. Модифицировать программу так, чтобы вычислялась степень с любым основанием. 

#include <iostream>

// Функция для вычисления степени числа base^exponent
double power(double base, int exponent) {
    double result = 1.0;
    for (int i = 0; i < exponent; i++) {
        result *= base;  // Умножаем result на base exponent раз
    }
    return result;
}

int main() {
    double base;
    int exponent;

    std::cout << "Введите основание: ";
    std::cin >> base;
    std::cout << "Введите степень: ";
    std::cin >> exponent;

    double result = power(base, exponent);  // Вызываем функцию power для вычисления степени

    std::cout << base << " в степени " << exponent << " = " << result << std::endl;

    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2. Выполнить программу, иллюстрирующую разные операции с указателями. Повторить эксперимент для разных типов данных.

#include <stdio.h>

// Макрос для вывода информации о указателе
#define PR(x) printf("x=%p, *x=%d, &x=%p\n", (void*)x, *x, (void*)&x)

int main(void) {
    int mas[] = {100, 200, 300};  // Массив целых чисел
    int *ptr1, *ptr2;             // Указатели на целые числа

    ptr1 = mas;     // Указатель ptr1 указывает на начало массива mas
    ptr2 = &mas[2]; // Указатель ptr2 указывает на третий элемент массива mas

    PR(ptr1); // Вывод информации о ptr1
    ptr1++;   // Увеличиваем ptr1 на 1 (теперь он указывает на второй элемент массива)
    PR(ptr1); // Вывод информации о ptr1

    PR(ptr2); // Вывод информации о ptr2
    ++ptr2;   // Увеличиваем ptr2 на 1 (теперь он указывает на следующую ячейку памяти после третьего элемента)
    printf("ptr2-ptr1=%ld\n", ptr2 - ptr1);  // Вычисление разности указателей (результат в байтах)

    return 0;
}

В этой программе используются указатели на целые числа (int). Теперь мы можем повторить эксперимент для разных типов данных, например, для типа double:

#include <stdio.h>

// Макрос для вывода информации о указателе
#define PR(x) printf("x=%p, *x=%lf, &x=%p\n", (void*)x, *x, (void*)&x)

int main(void) {
    double mas[] = {3.14, 2.718, 1.618};  // Массив чисел с плавающей запятой
    double *ptr1, *ptr2;                   // Указатели на числа с плавающей запятой

    ptr1 = mas;     // Указатель ptr1 указывает на начало массива mas
    ptr2 = &mas[2]; // Указатель ptr2 указывает на третий элемент массива mas

    PR(ptr1); // Вывод информации о ptr1
    ptr1++;   // Увеличиваем ptr1 на 1 (теперь он указывает на второй элемент массива)
    PR(ptr1); // Вывод информации о ptr1

    PR(ptr2); // Вывод информации о ptr2
    ++ptr2;   // Увеличиваем ptr2 на 1 (теперь он указывает на следующую ячейку памяти после третьего элемента)
    printf("ptr2-ptr1=%ld\n", ptr2 - ptr1);  // Вычисление разности указателей (результат в байтах)

    return 0;
}

В этом примере мы использовали массив типа double и указатели типа double * для демонстрации операций с указателями для этого типа данных.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3. Написать программу, которая меняет местами значения двух переменных. В качестве параметра использовать int, int* и int&.

Структура программы — следующая: функция main() вводит переменные и вызывает другую функцию, которая и выполняет обмен:

#include <iostream.h>
void main (void)
{
int a=2, b=5;
void obmen1 (int, int);
void obmen2 (int*, int*);
void obmen3 (int&, int&);
cout << “до обмена: a= “<< а <<"b="<<b<< endl;
//вызов obmenl (int, int);
cout << “после обмена 1: а= “<< а <<"b="<<b<< endl;
//вызов obmen2 (int*, int*);
cout << “после обмена 2: a= “<< а <<"b="<<b<< endl;
//вызов obmen3 (inté&, inté&);
cout << “после обмена 3: a= “<< а <<”b="<<b<< endl;

Написать 3 варианта функции обмена. В качестве параметров эта функция в первый раз получает два параметра типа int, второй раз — типа int*, третий раз — типа int&. Придумайте способ достижения результата B каждом из трех вариантов.


1) Функция обмена с параметрами типа int:

void obmen1(int x, int y) {
    int temp = x;
    x = y;
    y = temp;
}


2) Функция обмена с параметрами типа int*:

void obmen2(int* x, int* y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}


3) Функция обмена с параметрами типа int&:

void obmen3(int& x, int& y) {
    int temp = x;
    x = y;
    y = temp;
}

Теперь давайте объединим это вместе в программе и вызовем каждую функцию обмена для переменных a и b, чтобы убедиться, что обмен происходит корректно для каждого типа параметров:

#include <iostream>

// Функция обмена с параметрами типа int
void obmen1(int x, int y) {
    int temp = x;
    x = y;
    y = temp;
}

// Функция обмена с параметрами типа int*
void obmen2(int* x, int* y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

// Функция обмена с параметрами типа int&
void obmen3(int& x, int& y) {
    int temp = x;
    x = y;
    y = temp;
}

int main() {
    int a = 2, b = 5;

    std::cout << "до обмена: a=" << a << ", b=" << b << std::endl;

    // Вызов функции обмена с параметрами типа int
    obmen1(a, b);
    std::cout << "после обмена 1: a=" << a << ", b=" << b << std::endl;

    // Вызов функции обмена с параметрами типа int*
    obmen2(&a, &b);
    std::cout << "после обмена 2: a=" << a << ", b=" << b << std::endl;

    // Вызов функции обмена с параметрами типа int&
    obmen3(a, b);
    std::cout << "после обмена 3: a=" << a << ", b=" << b << std::endl;

    return 0;
}

Эта программа демонстрирует использование трех различных функций обмена для переменных a и b с разными типами параметров (int, int*, и int&). Вы увидите, что после каждого вызова функции обмена значения переменных a и b действительно меняются в соответствии с ожиданиями.
